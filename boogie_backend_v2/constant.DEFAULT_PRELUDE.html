<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `DEFAULT_PRELUDE` constant in crate `boogie_backend_v2`."><meta name="keywords" content="rust, rustlang, rust-lang, DEFAULT_PRELUDE"><title>boogie_backend_v2::DEFAULT_PRELUDE - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc constant"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../boogie_backend_v2/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class="location"><a href="index.html">boogie_backend_v2</a></p><div id="sidebar-vars" data-name="DEFAULT_PRELUDE" data-ty="constant" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Constant <a href="index.html">boogie_backend_v2</a>::<wbr><a class="constant" href="">DEFAULT_PRELUDE</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/boogie_backend_v2/lib.rs.html#6" title="goto source code">[src]</a></span></h1><pre class="rust const">pub const DEFAULT_PRELUDE: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a> = b&quot;// ================================================================================\n// Notation\n\n// This files contains a Handlebars Rust template for the prover\&#39;s Boogie prelude.\n// The template language constructs allow the prelude to adjust the actual content\n// to multiple options. We only use a few selected template constructs which are\n// mostly self-explaining. See the handlebars crate documentation for more information.\n//\n// The object passed in as context for templates is the struct cli::Options and its\n// sub-structs.\n\n// ================================================================================\n// Domains\n\n// Debug tracking\n// --------------\n\n// Debug tracking is used to inject information used for model analysis. The generated code emits statements\n// like this:\n//\n//     assume $DebugTrackLocal(file_id, byte_index, var_idx, $Value);\n//\n// While those tracking assumptions are trivially true for the provers logic, the solver (at least Z3)\n// will construct a function mapping which appears in the model, e.g.:\n//\n//     $DebugTrackLocal -&gt; {\n//         1 440 0 (Vector (ValueArray |T@[Int]$Value!val!0| 0)) -&gt; true\n//         1 533 1 ($Integer 1) -&gt; true\n//         ...\n//         else -&gt; true\n//     }\n//\n// This information can then be read out from the model.\n\n\n// Tracks debug information for a parameter, local or a return parameter. Return parameter indices start at\n// the overall number of locals (including parameters).\nfunction $DebugTrackLocal(file_id: int, byte_index:  int, var_idx: int, $Value: $Value) : bool {\n  true\n}\n\n// Tracks at which location a function was aborted.\nfunction $DebugTrackAbort(file_id: int, byte_index: int, code: int) : bool {\n  true\n}\n\n// Tracks the $Value of a specification (sub-)expression.\nfunction $DebugTrackExp(node_id: int, $Value: $Value) : $Value { $Value }\n\n\n// Path type\n// ---------\n\ntype {:datatype} $Path;\nfunction {:constructor} $Path(p: [int]int, size: int): $Path;\nconst $EmptyPath: $Path;\naxiom size#$Path($EmptyPath) == 0;\n\nfunction {:inline} $path_index_at(p: $Path, i: int): int {\n    p#$Path(p)[i]\n}\n\n// Type Values\n// -----------\n\ntype $TypeName;\ntype $FieldName = int;\ntype $LocalName;\ntype {:datatype} $TypeValue;\nfunction {:constructor} $BooleanType() : $TypeValue;\nfunction {:constructor} $IntegerType() : $TypeValue;\nfunction {:constructor} $AddressType() : $TypeValue;\nfunction {:constructor} $StrType() : $TypeValue;\nfunction {:constructor} $VectorType(t: $TypeValue) : $TypeValue;\nfunction {:constructor} $StructType(name: $TypeName, ts: $TypeValueArray) : $TypeValue;\nfunction {:constructor} $TypeType(): $TypeValue;\nfunction {:constructor} $ErrorType() : $TypeValue;\n\nfunction {:inline} $DefaultTypeValue() : $TypeValue { $ErrorType() }\nfunction {:builtin \&quot;MapConst\&quot;} $MapConstTypeValue(tv: $TypeValue): [int]$TypeValue;\n\ntype {:datatype} $TypeValueArray;\nfunction {:constructor} $TypeValueArray(v: [int]$TypeValue, l: int): $TypeValueArray;\nconst $EmptyTypeValueArray: $TypeValueArray;\naxiom l#$TypeValueArray($EmptyTypeValueArray) == 0;\naxiom v#$TypeValueArray($EmptyTypeValueArray) == $MapConstTypeValue($DefaultTypeValue());\n\n\n\n// Values\n// ------\n\ntype {:datatype} $Value;\n\nconst $MAX_U8: int;\naxiom $MAX_U8 == 255;\nconst $MAX_U64: int;\naxiom $MAX_U64 == 18446744073709551615;\nconst $MAX_U128: int;\naxiom $MAX_U128 == 340282366920938463463374607431768211455;\n\nfunction {:constructor} $Boolean(b: bool): $Value;\nfunction {:constructor} $Integer(i: int): $Value;\nfunction {:constructor} $Address(a: int): $Value;\nfunction {:constructor} $Vector(v: $ValueArray): $Value; // used to both represent Move Struct and Vector\nfunction {:constructor} $Range(lb: int, ub: int): $Value;\nfunction {:constructor} $Type(t: $TypeValue): $Value;\nfunction {:constructor} $Error(): $Value;\n\nfunction {:inline} $DefaultValue(): $Value { $Error() }\nfunction {:builtin \&quot;MapConst\&quot;} $MapConstValue(v: $Value): [int]$Value;\n\nfunction {:inline} $IsValidBox(v: $Value): bool {\n    true\n}\n\nfunction {:inline} $IsValidBox_int(v: $Value): bool {\n  is#$Integer(v)\n}\n\nfunction {:inline} $IsValidBox_bool(v: $Value): bool {\n  is#$Boolean(v)\n}\n\nfunction {:inline} $IsValidBox_addr(v: $Value): bool {\n  is#$Address(v)\n}\n\nfunction {:inline} $IsValidBox_vec(v: $Value): bool {\n  is#$Vector(v)\n}\n\nfunction {:inline} $IsValidU8Boxed(v: $Value): bool {\n  $IsValidBox_int(v) &amp;&amp; $IsValidU8($Unbox_int(v))\n}\n\nfunction {:inline} $IsValidBool(v: bool): bool {\n  true\n}\n\nfunction {:inline} $IsValidU8(v: int): bool {\n  $TagU8(v) &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= $MAX_U8\n}\n\nfunction {:inline} $IsValidU8Vector(v: $ValueArray): bool {\n  $Vector_$is_well_formed($IntegerType(), v) &amp;&amp;\n  (forall i: int :: {$ReadValueArray(v, i)} 0 &lt;= i &amp;&amp; i &lt; $LenValueArray(v) ==&gt; $IsValidU8Boxed($ReadValueArray(v, i)))\n}\n\nfunction {:inline} $IsValidU64(v: int): bool {\n  $TagU64(v) &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= $MAX_U64\n}\n\nfunction {:inline} $IsValidU128(v: int): bool {\n  $TagU128(v) &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= $MAX_U128\n}\n\nfunction {:inline} $IsValidNum(v: int): bool {\n  $TagNum(v) &amp;&amp; true\n}\n\nfunction {:inline} $IsValidAddress(v: int): bool {\n  // TODO: restrict max to representable addresses?\n  $TagAddr(v) &amp;&amp; v &gt;= 0\n}\n\n// Non-inlined type tagging functions. Those are added to type assumptions to provide\n// a trigger for quantifier instantiation based on type information.\nfunction $TagBool(x: bool): bool { true }\nfunction $TagU8(x: int): bool { true }\nfunction $TagU64(x: int): bool { true }\nfunction $TagU128(x: int): bool { true }\nfunction $TagNum(x: int): bool { true }\nfunction $TagAddr(x: int): bool { true }\nfunction $TagType(x: $TypeValue): bool { true }\nfunction $TagVec(et: $TypeValue, x: $ValueArray): bool { true }\n\n\nfunction {:inline} $IsValidRange(r: $Value): bool {\n   $IsValidU64(lb#$Range(r)) &amp;&amp;  $IsValidU64(ub#$Range(r))\n}\n\nfunction {:inline} $InRange(r: $Value, i: int): bool {\n   lb#$Range(r) &lt;= i &amp;&amp; i &lt; ub#$Range(r)\n}\n\n// Boxing/unboxing of values based on type suffix\n// ----------------------------------------------\n\nfunction {:inline} $Box(x: $Value): $Value {\n    x\n}\nfunction {:inline} $Box_int(x: int): $Value {\n    $Integer(x)\n}\nfunction {:inline} $Box_bool(x: bool): $Value {\n    $Boolean(x)\n}\nfunction {:inline} $Box_addr(x: int): $Value {\n    $Address(x)\n}\nfunction {:inline} $Box_vec(x: $ValueArray): $Value {\n    $Vector(x)\n}\n\nfunction {:inline} $Unbox(x: $Value): $Value {\n    x\n}\nfunction {:inline} $Unbox_int(x: $Value): int {\n    i#$Integer(x)\n}\nfunction {:inline} $Unbox_bool(x: $Value): bool {\n    b#$Boolean(x)\n}\nfunction {:inline} $Unbox_addr(x: $Value): int {\n    a#$Address(x)\n}\nfunction {:inline} $Unbox_vec(x: $Value): $ValueArray {\n    v#$Vector(x)\n}\n\n\n\n\n// Value Array\n// -----------\n\ntype {:datatype} $ValueArray;\n\nfunction {:constructor} $ValueArray(v: [int]$Value, l: int): $ValueArray;\n\nfunction $EmptyValueArray(): $ValueArray;\naxiom l#$ValueArray($EmptyValueArray()) == 0;\naxiom v#$ValueArray($EmptyValueArray()) == $MapConstValue($Error());\n\nfunction {:inline} $ValueArray_$is_well_formed(v: $ValueArray): bool {\n    (\n        var l := l#$ValueArray(v);\n        0 &lt;= l &amp;&amp; l &lt;= $MAX_U64\n    )\n}\n\nfunction {{backend.func_inline}} $ReadValueArray(a: $ValueArray, i: int): $Value {\n    (\n        v#$ValueArray(a)[i]\n    )\n}\n\nfunction {{backend.func_inline}} $LenValueArray(a: $ValueArray): int {\n    (\n        l#$ValueArray(a)\n    )\n}\n\nfunction {{backend.func_inline}} $RemoveValueArray(a: $ValueArray): $ValueArray {\n    (\n        var l := l#$ValueArray(a) - 1;\n        $ValueArray(\n            (lambda i: int ::\n                if i &gt;= 0 &amp;&amp; i &lt; l then v#$ValueArray(a)[i] else $DefaultValue()),\n            l\n        )\n    )\n}\n\nfunction {{backend.func_inline}} $SingleValueArray(v: $Value): $ValueArray {\n    $ValueArray($MapConstValue($DefaultValue())[0 := v], 1)\n}\n\nfunction {{backend.func_inline}} $RemoveIndexValueArray(a: $ValueArray, i: int): $ValueArray {\n    (\n        var l := l#$ValueArray(a) - 1;\n        $ValueArray(\n            (lambda j: int ::\n                if j &gt;= 0 &amp;&amp; j &lt; l then\n                    if j &lt; i then v#$ValueArray(a)[j] else v#$ValueArray(a)[j+1]\n                else $DefaultValue()),\n            l\n        )\n    )\n}\n\nfunction {{backend.func_inline}} $ConcatValueArray(a1: $ValueArray, a2: $ValueArray): $ValueArray {\n    (\n        var l1, m1, l2, m2 := l#$ValueArray(a1), v#$ValueArray(a1), l#$ValueArray(a2), v#$ValueArray(a2);\n        $ValueArray(\n            (lambda i: int ::\n                if i &gt;= 0 &amp;&amp; i &lt; l1 + l2 then\n                    if i &lt; l1 then m1[i] else m2[i - l1]\n                else\n                    $DefaultValue()),\n            l1 + l2)\n    )\n}\n\nfunction {{backend.func_inline}} $ReverseValueArray(a: $ValueArray): $ValueArray {\n    (\n        var l := l#$ValueArray(a);\n        $ValueArray(\n            (lambda i: int :: if 0 &lt;= i &amp;&amp; i &lt; l then v#$ValueArray(a)[l - i - 1] else $DefaultValue()),\n            l\n        )\n    )\n}\n\nfunction {{backend.func_inline}} $SliceValueArray(a: $ValueArray, i: int, j: int): $ValueArray { // return the sliced vector of a for the range [i, j)\n    $ValueArray((lambda k:int :: if 0 &lt;= k &amp;&amp; k &lt; j-i then v#$ValueArray(a)[i+k] else $DefaultValue()), (if j-i &lt; 0 then 0 else j-i))\n}\n\nfunction {{backend.func_inline}} $SliceValueArrayByRange(a: $ValueArray, r: $Value): $ValueArray {\n    $SliceValueArray(a, lb#$Range(r), ub#$Range(r))\n}\n\nfunction {{backend.func_inline}} $ExtendValueArray(a: $ValueArray, elem: $Value): $ValueArray {\n    (var len := l#$ValueArray(a);\n     $ValueArray(v#$ValueArray(a)[len := elem], len + 1))\n}\n\nfunction {{backend.func_inline}} $UpdateValueArray(a: $ValueArray, i: int, elem: $Value): $ValueArray {\n    $ValueArray(v#$ValueArray(a)[i := elem], l#$ValueArray(a))\n}\n\nfunction {{backend.func_inline}} $SwapValueArray(a: $ValueArray, i: int, j: int): $ValueArray {\n    $ValueArray(v#$ValueArray(a)[i := v#$ValueArray(a)[j]][j := v#$ValueArray(a)[i]], l#$ValueArray(a))\n}\n\nfunction {:inline} $IsEmpty(a: $ValueArray): bool {\n    l#$ValueArray(a) == 0\n}\n\n// All invalid elements of array are DefaultValue. This is useful in specialized\n// cases. This is used to defined normalization for $Vector\nfunction {:inline} $IsNormalizedValueArray(a: $ValueArray, len: int): bool {\n    (forall i: int :: i &lt; 0 || i &gt;= len ==&gt; v#$ValueArray(a)[i] == $DefaultValue())\n}\n\nfunction {{backend.func_inline}} $ContainValueArray(a: $ValueArray, v: $Value): bool {\n    (var len := l#$ValueArray(a);\n     (exists i: int :: i &gt;= 0 &amp;&amp; i &lt; len &amp;&amp; $IsEqual(v#$ValueArray(a)[i], v)))\n}\n\nfunction {{backend.func_inline}} $InValueArrayRange(v: $ValueArray, i: int): bool {\n    i &gt;= 0 &amp;&amp; i &lt; $LenValueArray(v)\n}\n\n// Value Multiset\n// --------------\n\n// An encoding of set elements. Because $Value has no extensional equality, we need this.\ntype $ValueMultisetElem;\nfunction $EncodeMultisetElem(elem: $Value): $ValueMultisetElem;\naxiom (forall v1, v2: $Value :: {$EncodeMultisetElem(v1), $EncodeMultisetElem(v2)}\n    $IsEqual(v1, v2) &lt;==&gt; $EncodeMultisetElem(v1) == $EncodeMultisetElem(v2));\n\n\ntype {:datatype} $ValueMultiset;\nfunction {:constructor} $ValueMultiset(v: [$ValueMultisetElem]int, l: int): $ValueMultiset;\n\nfunction {:builtin \&quot;MapConst\&quot;} $MapConstInt(l: int): [$ValueMultisetElem]int;\n\nconst $EmptyValueMultiset: $ValueMultiset;\naxiom $IsEmptyValueMultiset($EmptyValueMultiset);\n\nfunction {{backend.func_inline}} $LenValueMultiset(s: $ValueMultiset): int {\n    l#$ValueMultiset(s)\n}\n\nfunction {{backend.func_inline}} $ExtendValueMultiset(s: $ValueMultiset, v: $Value): $ValueMultiset {\n    (var enc := $EncodeMultisetElem(v);\n    (var len := l#$ValueMultiset(s);\n    (var cnt := v#$ValueMultiset(s)[enc];\n    $ValueMultiset(v#$ValueMultiset(s)[enc := (cnt + 1)], len + 1))))\n}\n\n// This function returns (s1 - s2). This function assumes that s2 is a subset of s1.\nfunction {{backend.func_inline}} $SubtractValueMultiset(s1: $ValueMultiset, s2: $ValueMultiset): $ValueMultiset {\n    (var len1 := l#$ValueMultiset(s1);\n    (var len2 := l#$ValueMultiset(s2);\n    $ValueMultiset((lambda v:$ValueMultisetElem :: v#$ValueMultiset(s1)[v]-v#$ValueMultiset(s2)[v]), len1-len2)))\n}\n\nfunction {:inline} $IsEmptyValueMultiset(s: $ValueMultiset): bool {\n    (l#$ValueMultiset(s) == 0) &amp;&amp;\n    (forall v: $ValueMultisetElem :: v#$ValueMultiset(s)[v] == 0)\n}\n\nfunction {:inline} $IsSubsetValueMultiset(s1: $ValueMultiset, s2: $ValueMultiset): bool {\n    (l#$ValueMultiset(s1) &lt;= l#$ValueMultiset(s2)) &amp;&amp;\n    (forall v: $ValueMultisetElem :: v#$ValueMultiset(s1)[v] &lt;= v#$ValueMultiset(s2)[v])\n}\n\nfunction {{backend.func_inline}} $ContainValueMultiset(s: $ValueMultiset, v: $Value): bool {\n    (var enc := $EncodeMultisetElem(v);\n    v#$ValueMultiset(s)[enc] &gt; 0)\n}\n\n\n// Stratified Functions on Values\n// ------------------------------\n\nconst $StratificationDepth: int;\naxiom $StratificationDepth == {{backend.stratification_depth}};\n\n{{#if backend.native_equality}}\n\n// Map IsEqual to native Boogie equality. This only works with extensional arrays as provided\n// by the array theory.\nfunction {:inline} $IsEqual(v1: $Value, v2: $Value): bool {\n    v1 == v2\n}\n\n{{else}}\n\n// Generate a stratified version of IsEqual for depth of {{backend.stratification_depth}}.\n{{#stratified}}\nfunction {{backend.aggressive_func_inline}} $IsEqual_{{@this_suffix}}(v1: $Value, v2: $Value): bool {\n    (v1 == v2) ||\n    (is#$Vector(v1) &amp;&amp;\n     is#$Vector(v2) &amp;&amp;\n     (var va1 := $Unbox_vec(v1);\n     (var va2 := $Unbox_vec(v2);\n      $LenValueArray(va1) == $LenValueArray(va2) &amp;&amp;\n      (forall i: int :: 0 &lt;= i &amp;&amp; i &lt; $LenValueArray(va1) ==&gt;\n          $IsEqual_{{@next_suffix}}($ReadValueArray(va1,i), $ReadValueArray(va2,i))))))\n}\n{{else}}\nfunction {:inline} $IsEqual_{{@this_suffix}}(v1: $Value, v2: $Value): bool {\n    v1 == v2\n}\n{{/stratified}}\n\nfunction {:inline} $IsEqual(v1: $Value, v2: $Value): bool {\n    $IsEqual_stratified(v1, v2)\n}\n\n\n\n{{/if}}\n\n// Generate stratified $UpdateValue for the depth of {{backend.stratification_depth}}.\n\n{{#stratified}}\nfunction {{backend.aggressive_func_inline}} $UpdateValue_{{@this_suffix}}(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {\n    (var poffset := offset + {{@this_level}};\n    if (poffset == size#$Path(p)) then\n        new_v\n    else\n        (var va := $Unbox_vec(v);\n         $Box_vec($UpdateValueArray(va, $path_index_at(p, poffset),\n                       $UpdateValue_{{@next_suffix}}(p, offset, $ReadValueArray(va, $path_index_at(p, poffset)), new_v)))))\n}\n{{else}}\nfunction {:inline} $UpdateValue_{{@this_suffix}}(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {\n    new_v\n}\n{{/stratified}}\n\nfunction {:inline} $UpdateValue(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {\n    $UpdateValue_stratified(p, offset, v, new_v)\n}\n\n// Generate stratified $IsPathPrefix for the depth of {{backend.stratification_depth}}.\n\n{{#stratified}}\nfunction {{backend.aggressive_func_inline}} $IsPathPrefix_{{@this_suffix}}(p1: $Path, p2: $Path): bool {\n    if ({{@this_level}} == size#$Path(p1)) then\n        true\n    else if (p#$Path(p1)[{{@this_level}}] == p#$Path(p2)[{{@this_level}}]) then\n        $IsPathPrefix_{{@next_suffix}}(p1, p2)\n    else\n        false\n}\n{{else}}\nfunction {:inline} $IsPathPrefix_{{@this_suffix}}(p1: $Path, p2: $Path): bool {\n    true\n}\n{{/stratified}}\n\nfunction {:inline} $IsPathPrefix(p1: $Path, p2: $Path): bool {\n    $IsPathPrefix_stratified(p1, p2)\n}\n\n// Generate stratified $ConcatPath for the depth of {{backend.stratification_depth}}.\n\n{{#stratified}}\nfunction {{backend.aggressive_func_inline}} $ConcatPath_{{@this_suffix}}(p1: $Path, p2: $Path): $Path {\n    if ({{@this_level}} == size#$Path(p2)) then\n        p1\n    else\n        $ConcatPath_{{@next_suffix}}($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[{{@this_level}}]], size#$Path(p1) + 1), p2)\n}\n{{else}}\nfunction {:inline} $ConcatPath_{{@this_suffix}}(p1: $Path, p2: $Path): $Path {\n    p1\n}\n{{/stratified}}\n\nfunction {:inline} $ConcatPath(p1: $Path, p2: $Path): $Path {\n    $ConcatPath_stratified(p1, p2)\n}\n\n// Type specific equality\n// ----------------------\n\nfunction {{backend.func_inline}} $IsEqual_int(x: int, y: int): bool {\n    x == y\n}\n\nfunction {{backend.func_inline}} $IsEqual_addr(x: int, y: int): bool {\n    x == y\n}\n\nfunction {{backend.func_inline}} $IsEqual_bool(x: bool, y: bool): bool {\n    x == y\n}\n\nfunction {{backend.func_inline}} $IsEqual_type(x: $TypeValue, y: $TypeValue): bool {\n    x == y\n}\n\nfunction {{backend.func_inline}} $IsEqual_vec(x: $ValueArray, y: $ValueArray): bool {\n    (x == y) ||\n    ( $LenValueArray(x) == $LenValueArray(y) &amp;&amp;\n      (forall i: int:: i &gt;= 0 &amp;&amp; i &lt; $LenValueArray(x) ==&gt; $IsEqual($ReadValueArray(x, i), $ReadValueArray(y, i)))\n    )\n}\n\n\n// ============================================================================================\n// Memory\n\ntype {:datatype} $Location;\n\n// A global resource location within the statically known resource type\&#39;s memory.\n// `ts` are the type parameters for the outer type, and `a` is the address.\nfunction {:constructor} $Global(ts: $TypeValueArray, a: int): $Location;\n\n// A local location. `i` is the unique index of the local.\nfunction {:constructor} $Local(i: int): $Location;\n\n// The location of a reference outside of the verification scope, for example, a `&amp;mut` parameter\n// of the function being verified. References with these locations don\&#39;t need to be written back\n// when mutation ends.\nfunction {:constructor} $Param(i: int): $Location;\n\n\n// A mutable reference which also carries its current value. Since mutable references\n// are single threaded in Move, we can keep them together and treat them as a value\n// during mutation until the point they are stored back to their original location.\ntype {:datatype} $Mutation;\nfunction {:constructor} $Mutation(l: $Location, p: $Path, v: $Value): $Mutation;\n\n// Representation of memory for a given type. The maps take the content of a Global location.\ntype {:datatype} $Memory;\nfunction {:constructor} $Memory(domain: [$TypeValueArray, int]bool, contents: [$TypeValueArray, int]$ValueArray): $Memory;\n\nfunction {:inline} $Memory__is_well_formed(m: $Memory): bool {\n    true\n}\n\nfunction {:builtin \&quot;MapConst\&quot;} $ConstMemoryDomain(v: bool): [$TypeValueArray, int]bool;\nfunction {:builtin \&quot;MapConst\&quot;} $ConstMemoryContent(v: $ValueArray): [$TypeValueArray, int]$ValueArray;\naxiom $ConstMemoryDomain(false) == (lambda ta: $TypeValueArray, i: int :: false);\naxiom $ConstMemoryDomain(true) == (lambda ta: $TypeValueArray, i: int :: true);\n\nconst $EmptyMemory: $Memory;\naxiom domain#$Memory($EmptyMemory) == $ConstMemoryDomain(false);\naxiom contents#$Memory($EmptyMemory) == $ConstMemoryContent($EmptyValueArray());\n\n// Returns a new memory which is identical than the given memory except at (type_args, addr) which\n// is arbitrary.\nprocedure {:inline 1} $Modifies(m: $Memory, type_args: $TypeValueArray, addr: int) returns (m\&#39;: $Memory) {\n    m\&#39; := $Memory(\n        domain#$Memory(m)[type_args, addr := domain#$Memory(m\&#39;)[type_args, addr]],\n        contents#$Memory(m)[type_args, addr := contents#$Memory(m\&#39;)[type_args, addr]]\n    );\n}\n\n// ============================================================================================\n// EventStore\n\n// The abstract type of guids, used to index EventStore\ntype $AbstractGuid;\n\n// An bijective mapping of guids to abstract guids. Since we use Guids as array indices, we\n// need to map them into a value which provides extensional equality.\nfunction $ToAbstractGuid(vec: $ValueArray): $AbstractGuid;\naxiom (forall v1, v2: $ValueArray :: {$ToAbstractGuid(v1), $ToAbstractGuid(v2)}\n    $IsEqual_vec(v1, v2) &lt;==&gt; $ToAbstractGuid(v1) == $ToAbstractGuid(v2));\n\n// The well-known field index of the event handle guid.\nconst $EventHandle_$guid: $FieldName;\naxiom $EventHandle_$guid == 1;\n\n// Representation of EventStore that consists of event streams. The map `streams` takes GUIDs (with type of $Value),\n// and returns sequences of messages (with type of $ValueArray).\ntype {:datatype} $EventStore;\nfunction {:constructor} $EventStore(counter: int, streams: [$AbstractGuid]$ValueMultiset): $EventStore;\n\nfunction {:inline} $EventStore__is_well_formed(es: $EventStore): bool {\n    true\n}\n\n\nfunction {:inline} $EventStore__is_empty(es: $EventStore): bool {\n    (counter#$EventStore(es) == 0) &amp;&amp;\n    (forall guid: $AbstractGuid ::\n        (var stream := streams#$EventStore(es)[guid];\n        $IsEmptyValueMultiset(stream)))\n}\n\n// This function returns (es1 - es2). This function assumes that es2 is a subset of es1.\nfunction {:inline} $EventStore__subtract(es1: $EventStore, es2: $EventStore): $EventStore {\n    $EventStore(counter#$EventStore(es1)-counter#$EventStore(es2),\n        (lambda guid: $AbstractGuid ::\n        $SubtractValueMultiset(\n            streams#$EventStore(es1)[guid],\n            streams#$EventStore(es2)[guid])))\n}\n\nfunction {:inline} $EventStore__is_subset(es1: $EventStore, es2: $EventStore): bool {\n    (counter#$EventStore(es1) &lt;= counter#$EventStore(es2)) &amp;&amp;\n    (forall guid: $AbstractGuid ::\n        $IsSubsetValueMultiset(\n            streams#$EventStore(es1)[guid],\n            streams#$EventStore(es2)[guid]\n        )\n    )\n}\n\nprocedure {:inline 1} $EventStore__diverge(es: $EventStore) returns (es\&#39;: $EventStore) {\n    assume $EventStore__is_subset(es, es\&#39;);\n}\n\nconst $EmptyEventStore: $EventStore;\naxiom $EventStore__is_empty($EmptyEventStore);\n\nfunction {:inline} $ExtendEventStore(es: $EventStore, guid: $ValueArray, msg: $Value): $EventStore {\n    (var abstract_guid := $ToAbstractGuid(guid);\n    (var stream := streams#$EventStore(es)[abstract_guid];\n    (var stream_new := $ExtendValueMultiset(stream, msg);\n    $EventStore(counter#$EventStore(es)+1, streams#$EventStore(es)[abstract_guid := stream_new]))))\n}\n\nfunction {:inline} $CondExtendEventStore(es: $EventStore, guid: $ValueArray, msg: $Value, cond: bool): $EventStore {\n    if cond then\n        $ExtendEventStore(es, guid, msg)\n    else\n        es\n}\n\nfunction {:inline} $GetEventHandleGuid(handle: $ValueArray): $ValueArray {\n    $Unbox_vec($ReadValueArray(handle, $EventHandle_$guid))\n}\n\nvar $es: $EventStore;\n\nvar $abort_flag: bool;\nvar $abort_code: int;\n\nfunction {:inline} $process_abort_code(code: int): int {\n    code\n}\n\nconst $EXEC_FAILURE_CODE: int;\naxiom $EXEC_FAILURE_CODE == -1;\n\n// TODO(wrwg): currently we map aborts of native functions like those for vectors also to\n//   execution failure. This may need to be aligned with what the runtime actually does.\n\nprocedure {:inline 1} $ExecFailureAbort() {\n    $abort_flag := true;\n    $abort_code := $EXEC_FAILURE_CODE;\n}\n\nprocedure {:inline 1} $InitVerification() {\n    // Set abort_flag to false, and havoc abort_code\n    $abort_flag := false;\n    havoc $abort_code;\n    // Assume that the EventStore is initially empty.\n    assume $EventStore__is_empty($es);\n}\n\n// ============================================================================================\n// Functional APIs\n\n// TODO: unify some of this with instruction procedures to avoid duplication\n\n// Tests whether resource exists.\nfunction {:inline} $ResourceExists(m: $Memory, args: $TypeValueArray, addr: int): bool {\n    domain#$Memory(m)[args, addr]\n}\n\n\n// Obtains Value of given resource.\nfunction {:inline} $ResourceValue(m: $Memory, args: $TypeValueArray, addr: int): $ValueArray {\n    contents#$Memory(m)[args, addr]\n}\n\n// Dereferences a mutation.\nfunction {:inline} $Dereference(ref: $Mutation): $Value {\n    v#$Mutation(ref)\n}\n\nfunction {:inline} $UpdateMutation(m: $Mutation, v: $Value): $Mutation {\n    $Mutation(l#$Mutation(m), p#$Mutation(m), v)\n}\n\nprocedure {:inline 1} $HavocMutation(m: $Mutation) returns (m\&#39;: $Mutation) {\n  var v\&#39;: $Value;\n  m\&#39; := $Mutation(l#$Mutation(m), p#$Mutation(m), v\&#39;);\n}\n\n// ============================================================================================\n// Instructions\n\nprocedure {:inline 1} $MoveTo(m: $Memory, ta: $TypeValueArray, a: int, v: $ValueArray) returns (m\&#39;: $Memory)\n{\n    if ($ResourceExists(m, ta, a)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    m\&#39; := $Memory(domain#$Memory(m)[ta, a := true], contents#$Memory(m)[ta, a := v]);\n}\n\nprocedure {:inline 1} $MoveFrom(m: $Memory, a: int, ta: $TypeValueArray) returns (m\&#39;: $Memory, dst: $ValueArray)\n{\n    if (!$ResourceExists(m, ta, a)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := contents#$Memory(m)[ta, a];\n    m\&#39; := $Memory(domain#$Memory(m)[ta, a := false], contents#$Memory(m)[ta, a := $EmptyValueArray()]);\n}\n\nprocedure {:inline 1} $BorrowGlobal(m: $Memory, a: int, ta: $TypeValueArray) returns (dst: $Mutation)\n{\n    if (!$ResourceExists(m, ta, a)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := $Mutation($Global(ta, a), $EmptyPath, $Box_vec(contents#$Memory(m)[ta, a]));\n}\n\nprocedure {:inline 1} $BorrowLoc(l: int, v: $Value) returns (dst: $Mutation)\n{\n    dst := $Mutation($Local(l), $EmptyPath, v);\n}\n\nprocedure {:inline 1} $BorrowField(src: $Mutation, f: $FieldName) returns (dst: $Mutation)\n{\n    var p: $Path;\n    var size: int;\n\n    p := p#$Mutation(src);\n    size := size#$Path(p);\n    p := $Path(p#$Path(p)[size := f], size+1);\n    dst := $Mutation(l#$Mutation(src), p, $ReadValueArray($Unbox_vec(v#$Mutation(src)), f));\n}\n\nprocedure {:inline 1} $GetGlobal(m: $Memory, a: int, ta: $TypeValueArray) returns (dst: $ValueArray)\n{\n    if (!$ResourceExists(m, ta, a)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := $ResourceValue(m, ta, a);\n}\n\nprocedure {:inline 1} $WritebackToGlobalWeak(m: $Memory, src: $Mutation) returns (m\&#39;: $Memory)\n{\n    var l: $Location;\n    var ta: $TypeValueArray;\n    var a: int;\n    var v: $Value;\n\n    l := l#$Mutation(src);\n    if (is#$Global(l)) {\n        ta := ts#$Global(l);\n        a := a#$Global(l);\n        v := $UpdateValue(p#$Mutation(src), 0, $Box_vec(contents#$Memory(m)[ta, a]), v#$Mutation(src));\n        m\&#39; := $Memory(domain#$Memory(m), contents#$Memory(m)[ta, a := $Unbox_vec(v)]);\n    } else {\n        m\&#39; := m;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueWeak(src: $Mutation, idx: int, vdst: $Value) returns (vdst\&#39;: $Value)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $UpdateValue(p#$Mutation(src), 0, vdst, v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueWeak_int(src: $Mutation, idx: int, vdst: int) returns (vdst\&#39;: int)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_int(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueWeak_bool(src: $Mutation, idx: int, vdst: bool) returns (vdst\&#39;: bool)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_bool(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueWeak_addr(src: $Mutation, idx: int, vdst: int) returns (vdst\&#39;: int)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_addr(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueWeak_vec(src: $Mutation, idx: int, vdst: $ValueArray) returns (vdst\&#39;: $ValueArray)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_vec($UpdateValue(p#$Mutation(src), 0, $Box_vec(vdst), v#$Mutation(src)));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\n\nprocedure {:inline 1} $WritebackToReferenceWeak(src: $Mutation, dst: $Mutation) returns (dst\&#39;: $Mutation)\n{\n    var srcPath, dstPath: $Path;\n\n    srcPath := p#$Mutation(src);\n    dstPath := p#$Mutation(dst);\n    if (l#$Mutation(dst) == l#$Mutation(src) &amp;&amp; size#$Path(dstPath) &lt;= size#$Path(srcPath) &amp;&amp; $IsPathPrefix(dstPath, srcPath)) {\n        dst\&#39; := $Mutation(\n                    l#$Mutation(dst),\n                    dstPath,\n                    $UpdateValue(srcPath, size#$Path(dstPath), v#$Mutation(dst), v#$Mutation(src)));\n    } else {\n        dst\&#39; := dst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToGlobalStrong(m: $Memory, src: $Mutation) returns (m\&#39;: $Memory)\n{\n    var l: $Location;\n    var ta: $TypeValueArray;\n    var a: int;\n    var v: $Value;\n\n    l := l#$Mutation(src);\n    if (is#$Global(l)) {\n        ta := ts#$Global(l);\n        a := a#$Global(l);\n        v := v#$Mutation(src);\n        m\&#39; := $Memory(domain#$Memory(m), contents#$Memory(m)[ta, a := $Unbox_vec(v)]);\n    } else {\n        m\&#39; := m;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueStrong(src: $Mutation, idx: int, vdst: $Value) returns (vdst\&#39;: $Value)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := v#$Mutation(src);\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueStrong_int(src: $Mutation, idx: int, vdst: int) returns (vdst\&#39;: int)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_int(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueStrong_bool(src: $Mutation, idx: int, vdst: bool) returns (vdst\&#39;: bool)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_bool(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueStrong_addr(src: $Mutation, idx: int, vdst: int) returns (vdst\&#39;: int)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_addr(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToValueStrong_vec(src: $Mutation, idx: int, vdst: $ValueArray) returns (vdst\&#39;: $ValueArray)\n{\n    if (l#$Mutation(src) == $Local(idx)) {\n        vdst\&#39; := $Unbox_vec(v#$Mutation(src));\n    } else {\n        vdst\&#39; := vdst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToReferenceStrongDirect(src: $Mutation, dst: $Mutation) returns (dst\&#39;: $Mutation)\n{\n    var srcPath, dstPath: $Path;\n\n    srcPath := p#$Mutation(src);\n    dstPath := p#$Mutation(dst);\n    if (l#$Mutation(dst) == l#$Mutation(src) &amp;&amp; size#$Path(dstPath) &lt;= size#$Path(srcPath) &amp;&amp; $IsPathPrefix(dstPath, srcPath)) {\n        dst\&#39; := $Mutation(\n                    l#$Mutation(dst),\n                    dstPath,\n                    v#$Mutation(src));\n    } else {\n        dst\&#39; := dst;\n    }\n}\n\nprocedure {:inline 1} $WritebackToReferenceStrongField(src: $Mutation, dst: $Mutation, edge: $FieldName)\nreturns (dst\&#39;: $Mutation)\n{\n    var srcPath, dstPath: $Path;\n\n    srcPath := p#$Mutation(src);\n    dstPath := p#$Mutation(dst);\n    if (l#$Mutation(dst) == l#$Mutation(src)) {\n        dst\&#39; := $Mutation(\n                    l#$Mutation(dst),\n                    dstPath,\n                    $Vector($UpdateValueArray(v#$Vector(v#$Mutation(dst)), edge, v#$Mutation(src)))\n                    );\n    } else {\n        dst\&#39; := dst;\n    }\n}\n\n\nprocedure {:inline 1} $WritebackToVec(src: $Mutation, dst: $Mutation)\nreturns (dst\&#39;: $Mutation)\n{\n    var srcPath, dstPath: $Path;\n\n    srcPath := p#$Mutation(src);\n    dstPath := p#$Mutation(dst);\n    if (l#$Mutation(dst) == l#$Mutation(src)) {\n        dst\&#39; := $Mutation(\n                    l#$Mutation(dst),\n                    dstPath,\n                    $Vector($UpdateValueArray(v#$Vector(v#$Mutation(dst)),\n                    $path_index_at(srcPath, size#$Path(srcPath) - 1), v#$Mutation(src)))\n                    );\n    } else {\n        dst\&#39; := dst;\n    }\n}\n\nprocedure {:inline 1} $Splice1(idx1: int, src1: $Mutation, dst: $Mutation) returns (dst\&#39;: $Mutation) {\n    dst\&#39; := $Mutation(l#$Mutation(src1), $ConcatPath(p#$Mutation(src1), p#$Mutation(dst)), v#$Mutation(dst));\n}\n\nprocedure {:inline 1} $CastU8(src: int) returns (dst: int)\n{\n    if (src &gt; $MAX_U8) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src;\n}\n\nprocedure {:inline 1} $CastU64(src: int) returns (dst: int)\n{\n    if (src &gt; $MAX_U64) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src;\n}\n\nprocedure {:inline 1} $CastU128(src: int) returns (dst: int)\n{\n    if (src &gt; $MAX_U128) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src;\n}\n\nprocedure {:inline 1} $AddU8(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 + src2 &gt; $MAX_U8) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 + src2;\n}\n\nprocedure {:inline 1} $AddU64(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 + src2 &gt; $MAX_U64) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 + src2;\n}\n\nprocedure {:inline 1} $AddU64_unchecked(src1: int, src2: int) returns (dst: int)\n{\n    dst := src1 + src2;\n}\n\nprocedure {:inline 1} $AddU128(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 + src2 &gt; $MAX_U128) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 + src2;\n}\n\nprocedure {:inline 1} $AddU128_unchecked(src1: int, src2: int) returns (dst: int)\n{\n    dst := src1 + src2;\n}\n\nprocedure {:inline 1} $Sub(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 &lt; src2) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 - src2;\n}\n\n// Note that *not* inlining the shl/shr functions avoids timeouts. It appears that Z3 can reason\n// better about this if it is an axiomatized function.\nfunction $shl(src1: int, p: int): int {\n    if p == 8 then src1 * 256\n    else if p == 16 then src1 * 65536\n    else if p == 32 then src1 * 4294967296\n    else if p == 64 then src1 * 18446744073709551616\n    // Value is undefined, otherwise.\n    else -1\n}\n\nfunction $shr(src1: int, p: int): int {\n    if p == 8 then src1 div 256\n    else if p == 16 then src1 div 65536\n    else if p == 32 then src1 div 4294967296\n    else if p == 64 then src1 div 18446744073709551616\n    // Value is undefined, otherwise.\n    else -1\n}\n\n// TODO: fix this and $Shr to drop bits on overflow. Requires $Shl8, $Shl64, and $Shl128\nprocedure {:inline 1} $Shl(src1: int, src2: int) returns (dst: int)\n{\n    var res: int;\n    res := $shl(src1, src2);\n    assert res &gt;= 0;   // restriction: shift argument must be 8, 16, 32, or 64\n    dst := res;\n}\n\nprocedure {:inline 1} $Shr(src1: int, src2: int) returns (dst: int)\n{\n    var res: int;\n    res := $shr(src1, src2);\n    assert res &gt;= 0;   // restriction: shift argument must be 8, 16, 32, or 64\n    dst := res;\n}\n\nprocedure {:inline 1} $MulU8(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 * src2 &gt; $MAX_U8) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 * src2;\n}\n\nprocedure {:inline 1} $MulU64(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 * src2 &gt; $MAX_U64) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 * src2;\n}\n\nprocedure {:inline 1} $MulU128(src1: int, src2: int) returns (dst: int)\n{\n    if (src1 * src2 &gt; $MAX_U128) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 * src2;\n}\n\nprocedure {:inline 1} $Div(src1: int, src2: int) returns (dst: int)\n{\n    if (src2 == 0) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 div src2;\n}\n\nprocedure {:inline 1} $Mod(src1: int, src2: int) returns (dst: int)\n{\n    if (src2 == 0) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := src1 mod src2;\n}\n\nprocedure {:inline 1} $ArithBinaryUnimplemented(src1: int, src2: int) returns (dst: int);\n\nprocedure {:inline 1} $Lt(src1: int, src2: int) returns (dst: bool)\n{\n    dst := src1 &lt; src2;\n}\n\nprocedure {:inline 1} $Gt(src1: int, src2: int) returns (dst: bool)\n{\n    dst := src1 &gt; src2;\n}\n\nprocedure {:inline 1} $Le(src1: int, src2: int) returns (dst: bool)\n{\n    dst := src1 &lt;= src2;\n}\n\nprocedure {:inline 1} $Ge(src1: int, src2: int) returns (dst: bool)\n{\n    dst := src1 &gt;= src2;\n}\n\nprocedure {:inline 1} $And(src1: bool, src2: bool) returns (dst: bool)\n{\n    dst := src1 &amp;&amp; src2;\n}\n\nprocedure {:inline 1} $Or(src1: bool, src2: bool) returns (dst: bool)\n{\n    dst := src1 || src2;\n}\n\nprocedure {:inline 1} $Not(src: bool) returns (dst: bool)\n{\n    dst := !src;\n}\n\n// Pack and Unpack are auto-generated for each type T\n\n\n// ==================================================================================\n// Native Vector Type\n\nfunction {:inline} $Vector_type_value(tv: $TypeValue): $TypeValue {\n    $VectorType(tv)\n}\n\nfunction {:inline} $Vector_$is_well_formed(et: $TypeValue, v: $ValueArray): bool {\n    $TagVec(et, v) &amp;&amp; $IsValidU64($LenValueArray(v)) &amp;&amp; $ValueArray_$is_well_formed(v)\n}\n\nprocedure {:inline 1} $Vector_empty(ta: $TypeValue) returns (v: $ValueArray) {\n    v := $EmptyValueArray();\n}\n\nfunction {:inline} $Vector_$empty(ta: $TypeValue): $ValueArray {\n    $EmptyValueArray()\n}\n\nprocedure {:inline 1} $Vector_is_empty(ta: $TypeValue, v: $ValueArray) returns (b: bool) {\n    b := $LenValueArray(v) == 0;\n}\n\nprocedure {:inline 1} $Vector_push_back(ta: $TypeValue, m: $Mutation, val: $Value) returns (m\&#39;: $Mutation) {\n    var v: $ValueArray;\n    v := $Unbox_vec($Dereference(m));\n    m\&#39; := $UpdateMutation(m, $Box_vec($ExtendValueArray(v, val)));\n}\n\nfunction {:inline} $Vector_$push_back(ta: $TypeValue, v: $ValueArray, val: $Value): $ValueArray {\n    $ExtendValueArray(v, val)\n}\n\nprocedure {:inline 1} $Vector_pop_back(ta: $TypeValue, m: $Mutation) returns (e: $Value, m\&#39;: $Mutation) {\n    var v: $ValueArray;\n    var len: int;\n    v := $Unbox_vec($Dereference(m));\n    len := $LenValueArray(v);\n    if (len == 0) {\n        call $ExecFailureAbort();\n        return;\n    }\n    e := $ReadValueArray(v, len-1);\n    m\&#39; := $UpdateMutation(m, $Box_vec($RemoveValueArray(v)));\n}\n\nprocedure {:inline 1} $Vector_append(ta: $TypeValue, m: $Mutation, other: $ValueArray) returns (m\&#39;: $Mutation) {\n    var v: $ValueArray;\n    v := $Unbox_vec($Dereference(m));\n    m\&#39; := $UpdateMutation(m, $Box_vec($ConcatValueArray(v, other)));\n}\n\nprocedure {:inline 1} $Vector_reverse(ta: $TypeValue, m: $Mutation) returns (m\&#39;: $Mutation) {\n    var v: $ValueArray;\n    v := $Unbox_vec($Dereference(m));\n    m\&#39; := $UpdateMutation(m, $Box_vec($ReverseValueArray(v)));\n}\n\nprocedure {:inline 1} $Vector_length(ta: $TypeValue, v: $ValueArray) returns (l: int) {\n    l := $LenValueArray(v);\n}\n\nfunction {:inline} $Vector_$length(ta: $TypeValue, v: $ValueArray): int {\n    $LenValueArray(v)\n}\n\nprocedure {:inline 1} $Vector_borrow(ta: $TypeValue, v: $ValueArray, i: int) returns (dst: $Value) {\n    if (i &lt; 0 || i &gt;= $LenValueArray(v)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    dst := $ReadValueArray(v, i);\n}\n\nfunction {:inline} $Vector_$borrow(ta: $TypeValue, v: $ValueArray, i: int): $Value {\n    $ReadValueArray(v, i)\n}\n\nprocedure {:inline 1} $Vector_borrow_mut(ta: $TypeValue, m: $Mutation, index: int) returns (dst: $Mutation, m\&#39;: $Mutation)\n{\n    var v: $ValueArray;\n    var p: $Path;\n    var size: int;\n\n    v := $Unbox_vec($Dereference(m));\n    if (index &lt; 0 || index &gt;= $LenValueArray(v)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    p := p#$Mutation(m);\n    size := size#$Path(p);\n    p := $Path(p#$Path(p)[size := index], size+1);\n    dst := $Mutation(l#$Mutation(m), p, $ReadValueArray(v, index));\n    m\&#39; := m;\n}\n\nfunction {:inline} $Vector_$borrow_mut(ta: $TypeValue, v: $ValueArray, i: int): $Value {\n    $ReadValueArray(v, i)\n}\n\nprocedure {:inline 1} $Vector_destroy_empty(ta: $TypeValue, v: $ValueArray) {\n    if ($LenValueArray(v) != 0) {\n      call $ExecFailureAbort();\n    }\n}\n\nprocedure {:inline 1} $Vector_swap(ta: $TypeValue, m: $Mutation, i: int, j: int) returns (m\&#39;: $Mutation)\n{\n    var v: $ValueArray;\n    v := $Unbox_vec($Dereference(m));\n    if (i &gt;= $LenValueArray(v) || j &gt;= $LenValueArray(v) || i &lt; 0 || j &lt; 0) {\n        call $ExecFailureAbort();\n        return;\n    }\n    m\&#39; := $UpdateMutation(m, $Box_vec($SwapValueArray(v, i, j)));\n}\n\nfunction {:inline} $Vector_$swap(ta: $TypeValue, v: $ValueArray, i: int, j: int): $ValueArray {\n    $SwapValueArray(v, i, j)\n}\n\nprocedure {:inline 1} $Vector_remove(ta: $TypeValue, m: $Mutation, i: int) returns (e: $Value, m\&#39;: $Mutation)\n{\n    var v: $ValueArray;\n\n    v := $Unbox_vec($Dereference(m));\n\n    if (i &lt; 0 || i &gt;= $LenValueArray(v)) {\n        call $ExecFailureAbort();\n        return;\n    }\n    e := $ReadValueArray(v, i);\n    m\&#39; := $UpdateMutation(m, $Box_vec($RemoveIndexValueArray(v, i)));\n}\n\nprocedure {:inline 1} $Vector_swap_remove(ta: $TypeValue, m: $Mutation, i: int) returns (e: $Value, m\&#39;: $Mutation)\n{\n    var len: int;\n    var v: $ValueArray;\n\n    v := $Unbox_vec($Dereference(m));\n\n    len := $LenValueArray(v);\n    if (i &lt; 0 || i &gt;= len) {\n        call $ExecFailureAbort();\n        return;\n    }\n    e := $ReadValueArray(v, i);\n    m\&#39; := $UpdateMutation(m, $Box_vec($RemoveValueArray($SwapValueArray(v, i, len-1))));\n}\n\nprocedure {:inline 1} $Vector_contains(ta: $TypeValue, v: $ValueArray, e: $Value) returns (res: bool)  {\n    res := $ContainValueArray(v, e);\n}\n\n// FIXME: This procedure sometimes (not always) make the test (performance_200511) very slow (&gt; 10 mins) or hang\n// although this is not used in the test script (performance_200511). The test finishes in 20 secs when it works fine.\nprocedure {:inline 1} $Vector_index_of(ta: $TypeValue, v: $ValueArray, e: $Value) returns (res1: bool, res2: int);\nensures 0 &lt;= res2 &amp;&amp; res2 &lt; $LenValueArray(v);\nensures res1 == $ContainValueArray(v, e);\nensures res1 ==&gt; $IsEqual($ReadValueArray(v, res2), e);\nensures res1 ==&gt; (forall i:int :: 0 &lt;= i &amp;&amp; i &lt; res2 ==&gt; !$IsEqual($ReadValueArray(v, i), e));\nensures !res1 ==&gt; res2 == 0;\n\n// ==================================================================================\n// Native hash\n\n// Hash is modeled as an otherwise uninterpreted injection.\n// In truth, it is not an injection since the domain has greater cardinality\n// (arbitrary length vectors) than the co-domain (vectors of length 32).  But it is\n// common to assume in code there are no hash collisions in practice.  Fortunately,\n// Boogie is not smart enough to recognized that there is an inconsistency.\n// FIXME: If we were using a reliable extensional theory of arrays, and if we could use ==\n// instead of $IsEqual, we might be able to avoid so many quantified formulas by\n// using a sha2_inverse function in the ensures conditions of Hash_sha2_256 to\n// assert that sha2/3 are injections without using global quantified axioms.\n\n\nfunction {:inline} $Hash_sha2(val: $ValueArray): $ValueArray {\n    $Hash_sha2_core(val)\n}\n\nfunction $Hash_sha2_core(val: $ValueArray): $ValueArray;\n\n// This says that Hash_sha2 is bijective.\naxiom (forall v1,v2: $ValueArray :: {$Hash_sha2_core(v1), $Hash_sha2_core(v2)}\n       $IsEqual_vec(v1, v2) &lt;==&gt; $IsEqual_vec($Hash_sha2_core(v1), $Hash_sha2_core(v2)));\n\n// This procedure has no body. We want Boogie to just use its requires\n// and ensures properties when verifying code that calls it.\nprocedure $Hash_sha2_256(val: $ValueArray) returns (res: $ValueArray);\n// It will still work without this, but this helps verifier find more reasonable counterexamples.\n{{backend.type_requires}} $IsValidU8Vector(val);\nensures res == $Hash_sha2_core(val);     // returns Hash_sha2 Value\nensures $IsValidU8Vector(res);    // result is a legal vector of U8s.\nensures $LenValueArray(res) == 32;               // result is 32 bytes.\n\n// Spec version of Move native function.\nfunction {:inline} $Hash_$sha2_256(val: $ValueArray): $ValueArray {\n    $Hash_sha2_core(val)\n}\n\n// similarly for Hash_sha3\nfunction {:inline} $Hash_sha3(val: $ValueArray): $ValueArray {\n    $Hash_sha3_core(val)\n}\nfunction $Hash_sha3_core(val: $ValueArray): $ValueArray;\n\naxiom (forall v1,v2: $ValueArray :: {$Hash_sha3_core(v1), $Hash_sha3_core(v2)}\n       $IsEqual_vec(v1, v2) &lt;==&gt; $IsEqual_vec($Hash_sha3_core(v1), $Hash_sha3_core(v2)));\n\nprocedure $Hash_sha3_256(val: $ValueArray) returns (res: $ValueArray);\nensures res == $Hash_sha3_core(val);     // returns Hash_sha3 Value\nensures $IsValidU8Vector(res);    // result is a legal vector of U8s.\nensures $LenValueArray(res) == 32;               // result is 32 bytes.\n\n// Spec version of Move native function.\nfunction {:inline} $Hash_$sha3_256(val: $ValueArray): $ValueArray {\n    $Hash_sha3_core(val)\n}\n\n// ==================================================================================\n// Native diem_account\n\nprocedure {:inline 1} $DiemAccount_create_signer(\n  addr: int\n) returns (signer: int) {\n    // A signer is currently identical to an address.\n    signer := addr;\n}\n\nprocedure {:inline 1} $DiemAccount_destroy_signer(\n  signer: int\n) {\n  return;\n}\n\n// ==================================================================================\n// Native Signer\n\nprocedure {:inline 1} $Signer_borrow_address(signer: int) returns (res: int) {\n    res := signer;\n}\n\n// ==================================================================================\n// Native signature\n\n// Signature related functionality is handled via uninterpreted functions. This is sound\n// currently because we verify every code path based on signature verification with\n// an arbitrary interpretation.\n\nfunction $Signature_$ed25519_validate_pubkey(public_key: $ValueArray): bool;\nfunction $Signature_$ed25519_verify(signature: $ValueArray, public_key: $ValueArray, message: $ValueArray): bool;\n\n// Needed because we do not have extensional equality:\naxiom (forall k1, k2: $ValueArray ::\n    {$Signature_$ed25519_validate_pubkey(k1), $Signature_$ed25519_validate_pubkey(k2)}\n    $IsEqual_vec(k1, k2) ==&gt; $Signature_$ed25519_validate_pubkey(k1) == $Signature_$ed25519_validate_pubkey(k2));\naxiom (forall s1, s2, k1, k2, m1, m2: $ValueArray ::\n    {$Signature_$ed25519_verify(s1, k1, m1), $Signature_$ed25519_verify(s2, k2, m2)}\n    $IsEqual_vec(s1, s2) &amp;&amp; $IsEqual_vec(k1, k2) &amp;&amp; $IsEqual_vec(m1, m2)\n    ==&gt; $Signature_$ed25519_verify(s1, k1, m1) == $Signature_$ed25519_verify(s2, k2, m2));\n\n\nprocedure {:inline 1} $Signature_ed25519_validate_pubkey(public_key: $ValueArray) returns (res: bool) {\n    res := $Signature_$ed25519_validate_pubkey(public_key);\n}\n\nprocedure {:inline 1} $Signature_ed25519_verify(\n        signature: $ValueArray, public_key: $ValueArray, message: $ValueArray) returns (res: bool) {\n    res := $Signature_$ed25519_verify(signature, public_key, message);\n}\n\n// ==================================================================================\n// Native BCS::serialize\n\n// native define serialize&lt;MoveValue&gt;(v: &amp;MoveValue): vector&lt;u8&gt;;\n\n// Serialize is modeled as an uninterpreted function, with an additional\n// axiom to say it\&#39;s an injection.\n\nfunction {:inline} $BCS_serialize(ta: $TypeValue, v: $Value): $ValueArray {\n    $BCS_serialize_core(v)\n}\n\nfunction $BCS_serialize_core(v: $Value): $ValueArray;\naxiom (forall v1, v2: $Value :: {$BCS_serialize_core(v1), $BCS_serialize_core(v2)}\n   $IsEqual(v1, v2) &lt;==&gt; $IsEqual_vec($BCS_serialize_core(v1), $BCS_serialize_core(v2)));\n\n// This says that serialize returns a non-empty vec&lt;u8&gt;\n{{#if (eq backend.serialize_bound 0)}}\naxiom (forall v: $Value :: {$BCS_serialize_core(v)}\n     ( var r := $BCS_serialize_core(v); $IsValidU8Vector(r) &amp;&amp; $LenValueArray(r) &gt; 0 ));\n{{else}}\naxiom (forall v: $Value :: {$BCS_serialize_core(v)}\n     ( var r := $BCS_serialize_core(v); $IsValidU8Vector(r) &amp;&amp; $LenValueArray(r) &gt; 0 &amp;&amp;\n                            $LenValueArray(r) &lt;= {{backend.serialize_bound}} ));\n{{/if}}\n\n// Serialized addresses should have the same length\nconst $serialized_address_len: int;\naxiom (forall v: $Value :: {$BCS_serialize_core(v)}\n     ( var r := $BCS_serialize_core(v); is#$Address(v) ==&gt; $LenValueArray(r) == $serialized_address_len));\n\nprocedure $BCS_to_bytes(ta: $TypeValue, v: $Value) returns (res: $ValueArray);\nensures res == $BCS_serialize_core(v);\n\nfunction {:inline} $BCS_$to_bytes(ta: $TypeValue, v: $Value): $ValueArray {\n    $BCS_serialize_core(v)\n}\n\n// ==================================================================================\n// Native Signer::spec_address_of\n\nfunction {:inline} $Signer_spec_address_of(signer: int): int\n{\n    // A signer is currently identical to an address.\n    signer\n}\n\nfunction {:inline} $Signer_$borrow_address(signer: int): int\n{\n    // A signer is currently identical to an address.\n    signer\n}\n\n// ==================================================================================\n// Mocked out Event module\n\nprocedure {:inline 1} $Event_new_event_handle(t: $TypeValue, signer: int) returns (res: $ValueArray) {\n}\n\nprocedure {:inline 1} $Event_publish_generator(account: int) {\n}\n\n// This boogie procedure is the model of `emit_event`. This model abstracts away the `counter` behavior, thus not\n// mutating (or increasing) `counter`.\n\nprocedure {:inline 1} $Event_emit_event(t: $TypeValue, handler: $Mutation, msg: $Value) returns (res: $Mutation) {\n    var guid: $ValueArray;\n    guid := $GetEventHandleGuid($Unbox_vec($Dereference(handler)));\n    $es := $ExtendEventStore($es, guid, msg);\n    res := handler;\n}\n\nprocedure {:inline 1} $Event_write_to_event_store(t: $TypeValue, guid: $ValueArray, count: int, msg: $Value) {\n    // This function should never be called as it is private to Event but the caller, emit_event, is mocked out.\n    assert false;\n}\n\nprocedure {:inline 1} $Event_destroy_handle(t: $TypeValue, handle: $ValueArray) {\n}\n&quot;;</pre></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="boogie_backend_v2"></div>
    <script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>